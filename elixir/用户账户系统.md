# ä»»åŠ¡ï¼š ç”Ÿæˆ context ä¸º Accounts çš„ç”¨æˆ·è´¦æˆ·ç³»ç»Ÿï¼ŒåŒ…å«ä»¥ä¸‹åŠŸèƒ½ï¼š

##  æ•°æ®ç»“æ„

ä»¥ä¸‹ä¸º PostgreSQL è¡¨ç»“æ„ï¼Œè¯·ä½¿ç”¨ migration æ¥ç”Ÿæˆã€‚

### è¡¨ï¼š`users`

* ç”¨æˆ·åŸºæœ¬ä¿¡æ¯è¡¨
* å­—æ®µï¼š

  * `id`: ä¸»é”®
  * `idname`: ç”¨æˆ·å”¯ä¸€æ ‡è¯†ï¼ˆå­—ç¬¦ä¸²ï¼Œæœ€é•¿ 60ï¼‰
  * `nickname`: æ˜µç§°ï¼ˆå­—ç¬¦ä¸²ï¼Œæœ€é•¿ 60ï¼‰
  * `email`: é‚®ç®±ï¼ˆcitextï¼Œä¸åŒºåˆ†å¤§å°å†™ï¼‰
  * `is_confirmed`: é‚®ç®±æ˜¯å¦å·²ç¡®è®¤ï¼ˆå¸ƒå°”ï¼Œé»˜è®¤ falseï¼‰
  * `confirmed_at`: é‚®ç®±ç¡®è®¤æ—¶é—´
  * `inserted_at`: åˆ›å»ºæ—¶é—´
  * `updated_at`: æ›´æ–°æ—¶é—´
  * `is_bot`: æ˜¯å¦ä¸ºæœºå™¨äººè´¦æˆ·ï¼ˆå¸ƒå°”ï¼Œé»˜è®¤ falseï¼‰

---

### è¡¨ï¼š`user_passwords`

* å­˜å‚¨ç”¨æˆ·å¯†ç å“ˆå¸Œ
* å­—æ®µï¼š

  * `id`: ä¸»é”®
  * `user_id`: å¤–é”® â†’ `users.id`
  * `password_hash`: å¯†ç å“ˆå¸Œï¼ˆæœ€é•¿ 64ï¼‰
  * `inserted_at`: åˆ›å»ºæ—¶é—´
  * `updated_at`: æ›´æ–°æ—¶é—´

* å¤‡æ³¨ï¼š
  *  ä½¿ç”¨ Bcrypt.hash\_pwd\_salt(password) æ¥ç”Ÿæˆå¯†ç å“ˆå¸Œ

---

### è¡¨ï¼š`user_sessions`

* ç”¨æˆ·ä¼šè¯ç®¡ç†è¡¨
* å­—æ®µï¼š

  * `id`: ä¸»é”®
  * `user_id`: å¤–é”® â†’ `users.id`
  * `auth_token`: è®¤è¯ä»¤ç‰Œï¼ˆäºŒè¿›åˆ¶ï¼‰
  * `user_agent`: ç”¨æˆ·è®¾å¤‡ä¿¡æ¯
  * `client_ip`: ç™»å½• IP
  * `expirable_at`: è¿‡æœŸæ—¶é—´
  * `is_oauth`: æ˜¯å¦ä¸º OAuth ç™»å½•ï¼ˆå¸ƒå°”ï¼Œé»˜è®¤ falseï¼‰
  * `inserted_at`: åˆ›å»ºæ—¶é—´
  * `updated_at`: æ›´æ–°æ—¶é—´

---

### è¡¨ï¼š`api_tokens`

* ç¬¬ä¸‰æ–¹ API è®¿é—®ä»¤ç‰Œ
* å­—æ®µï¼š

  * `id`: ä¸»é”®
  * `user_id`: å¤–é”® â†’ `users.id`
  * `auth_token`: è®¤è¯ä»¤ç‰Œï¼ˆäºŒè¿›åˆ¶ï¼‰
  * `description`: æè¿°ï¼ˆæœ€é•¿ 255ï¼‰
  * `expirable_at`: è¿‡æœŸæ—¶é—´ï¼ˆå¯ä¸ºç©ºï¼‰
  * `inserted_at`: åˆ›å»ºæ—¶é—´
  * `updated_at`: æ›´æ–°æ—¶é—´

---

### è¡¨ï¼š`verification_tokens`

* é‚®ç®±æˆ–è€…æ‰‹æœºçš„éªŒè¯æˆ–æ‰¾å›å¯†ç ä»¤ç‰Œ
* å­—æ®µï¼š

  * `id`: ä¸»é”®
  * `user_id`: å¤–é”® â†’ `users.id`
  * `channel`: æ¸ é“åç§° 'email' | 'sms' 
  * `token`: é‚®ç®±éªŒè¯ä»¤ç‰Œï¼ˆäºŒè¿›åˆ¶ï¼‰
  * `token_code`: 6ä½æ•°å­—éªŒè¯ç 
  * `email`: é‚®ç®±åœ°å€
  * `phone`: E.164 phoneï¼ˆé¢„ç•™å­—æ®µï¼Œå½“å‰å¹¶æ²¡æœ‰æ‰‹æœºå·ç™»å½•æµç¨‹ï¼‰
  * `scope`: ç”¨é€”èŒƒå›´ï¼ˆå¦‚ signupã€reset\_passwordï¼‰
  * `is_confirmed`: æ˜¯å¦å·²ä½¿ç”¨ï¼ˆé»˜è®¤ falseï¼‰
  * `expirable_at`: è¿‡æœŸæ—¶é—´
  * `inserted_at`: åˆ›å»ºæ—¶é—´
  * `updated_at`: æ›´æ–°æ—¶é—´

* å¤‡æ³¨:
  * `email` å’Œ `phone` å­—æ®µäºŒé€‰ä¸€ä½¿ç”¨ï¼Œå¿…é¡»å­˜åœ¨
  * `scope` å½“å‰æœ‰ä¸‰ç§å–å€¼ï¼š`signup`ï¼ˆæ³¨å†Œç¡®è®¤ï¼‰ï¼Œ`reset_password`ï¼ˆé‡ç½®å¯†ç ï¼‰`reset_email`ï¼ˆé‡ç½®é‚®ç®±ï¼‰

---

### ğŸ”— è¡¨å…³ç³»

* `users` â†â†’ `user_passwords`ï¼šä¸€å¯¹ä¸€
* `users` â†â†’ `user_sessions`ï¼šä¸€å¯¹å¤š
* `users` â†â†’ `api_tokens`ï¼šä¸€å¯¹å¤š
* `users` â†â†’ `email_tokens`ï¼šä¸€å¯¹å¤š

## æ¥å£

æ·»åŠ ä»¥ä¸‹ API æ¥å£

### ç”¨æˆ·æ³¨å†Œæ¥å£

1. è¯»å–å®¢æˆ·ç«¯ä¿¡æ¯ï¼ˆuser\_agent, client\_ip)
2. æ ¡éªŒè¯·æ±‚æ˜¯å¦åˆæ³•
3. æ•°æ®åº“åˆ›å»ºè´¦å·
4. å‘é€éªŒè¯é‚®ä»¶
5. ç”Ÿæˆ user\_token
6. ç™»å½•å¹¶å†™å›å“åº”ï¼ˆcookie/headersï¼‰
7. æ¸²æŸ“JSONç»“æœ

### ç”¨æˆ·ç™»å½•æ¥å£ï¼ˆemail + passwordï¼‰

1. è¯»å–å®¢æˆ·ç«¯ä¿¡æ¯ï¼ˆuser\_agent, client\_ip)
1. æ ¡éªŒè¯·æ±‚æ˜¯å¦åˆæ³•
1. é€šè¿‡ email å‚æ•°ï¼Œè·å–ç”¨æˆ·ä¿¡æ¯
1. æ ¡éªŒå¯†ç æ˜¯å¦æ­£ç¡®
1. ç™»å½•å¹¶å†™å›å“åº”ï¼ˆcookie/headersï¼‰
1. æ¸²æŸ“JSONç»“æœ

### ç”¨æˆ·é‚®ç®±ç¡®è®¤æ¥å£

æ”¯æŒ token å’Œæ•°å­— code ä¸¤ç§æ–¹å¼

1. è¯»å–å®¢æˆ·ç«¯ä¿¡æ¯ï¼ˆuser\_agent, client\_ip)
1. æ ¡éªŒè¯·æ±‚æ˜¯å¦åˆæ³•
1. ä» verification\_tokens è¡¨ä¸­ï¼ŒæŸ¥æ‰¾å¯¹åº” token
1. ç¡®è®¤ token æ˜¯å¦è¿‡æœŸ
1. æ ¡éªŒ token æ˜¯å¦æ­£ç¡®
1. email_token æ ‡è®°ä¸ºå·²ä½¿ç”¨
1. åˆ é™¤è¿™ä¸ªç”¨æˆ·çš„æ‰€æœ‰æœªä½¿ç”¨çš„åŒ scope çš„ token
1. æ¸²æŸ“JSONç»“æœ

### é‡ç½®å¯†ç æ¥å£

1. è¯»å–å®¢æˆ·ç«¯ä¿¡æ¯ï¼ˆuser\_agent, client\_ip)
1. æ ¡éªŒè¯·æ±‚æ˜¯å¦åˆæ³•
1. ä» verification\_tokens è¡¨ä¸­ï¼ŒæŸ¥æ‰¾å¯¹åº” token
1. ç¡®è®¤ token æ˜¯å¦è¿‡æœŸ
1. æ ¡éªŒ token æ˜¯å¦æ­£ç¡®
1. email_token æ ‡è®°ä¸ºå·²ä½¿ç”¨
1. åˆ é™¤è¿™ä¸ªç”¨æˆ·çš„æ‰€æœ‰æœªä½¿ç”¨çš„åŒ scope çš„ token
1. æ¸²æŸ“JSONç»“æœ

### å‘èµ·é‡ç½®å¯†ç æ¥å£

è§¦å‘â€œé‡ç½®å¯†ç â€æµç¨‹ï¼Œè®©ç³»ç»Ÿå‘ç”¨æˆ·é‚®ç®±å‘é€ä¸€å°åŒ…å« â€œå¯†ç é‡ç½®é“¾æ¥â€ çš„é‚®ä»¶

### é‡ç½®é‚®ç®±æ¥å£

åŒ é‡ç½®å¯†ç æ¥å£ï¼Œ ä½†æ˜¯ scope ä¸º reset\_email

### å‘èµ·é‡ç½®é‚®ç®±æ¥å£

åŒ å‘èµ·é‡ç½®å¯†ç æ¥å£ï¼Œ ä½†æ˜¯ scope ä¸º reset\_email

## è¿‡æœŸæ—¶é—´é…ç½®

verification_tokens è¡¨ä¸­çš„ token è¿‡æœŸæ—¶é—´ä¸º 7 å¤©

## idname å®šä¹‰

idname ä¸ºç”¨æˆ·çš„å”¯ä¸€æ ‡è¯†ç¬¦ï¼Œå‚è€ƒä»¥ä¸‹ä¼ªä»£ç ï¼š

```elixir
defmodule Cat.Validators.IdnameValidator do
  @moduledoc """
  ç”¨äºéªŒè¯ç”¨æˆ·åæ ¼å¼çš„éªŒè¯å™¨ï¼ˆæœ€ç»ˆè¿”å› {:ok, idname} æˆ– {:error, error}ï¼‰ã€‚
  ä¸â€œçŸ­è·¯â€æ–¹å¼ä¸åŒï¼Œè¿™é‡Œé‡‡ç”¨â€œç´¯åŠ é”™è¯¯â€çš„æ–¹å¼ï¼šæ‰€æœ‰éªŒè¯éƒ½ä¼šæ‰§è¡Œã€‚

  ç”¨æ³•ç¤ºä¾‹ï¼š

      case IdnameValidator.perform_validation("æµ‹è¯•ç”¨æˆ·å") do
        {:ok, idname} ->
          IO.puts("éªŒè¯é€šè¿‡: \#{idname}")
        {:error, error} ->
          IO.inspect(error, label: "éªŒè¯é”™è¯¯")
      end

  å‚è€ƒè‡ªï¼š
  https://raw.githubusercontent.com/discourse/discourse/refs/heads/main/app/models/username_validator.rb
  """

  @max_chars 60
  @idname_min_length 3
  @idname_max_length 30
  @confusing_extensions ~r/\.(js|json|css|htm|html|xml|jpg|jpeg|png|gif|bmp|ico|tif|tiff|woff)\z/i

  @ascii_invalid_char_pattern ~r/[^\w.-]/
  # All Unicode characters except for alphabetic and numeric character, marks and underscores are invalid.
  # In addition to that, the following letters and nonspacing marks are invalid:
  #   (U+034F) Combining Grapheme Joiner
  #   (U+115F) Hangul Choseong Filler
  #   (U+1160) Hangul Jungseong Filler
  #   (U+17B4) Khmer Vowel Inherent Aq
  #   (U+17B5) Khmer Vowel Inherent Aa
  #   (U+180B - U+180D) Mongolian Free Variation Selectors
  #   (U+3164) Hangul Filler
  #   (U+FFA0) Halfwidth Hangul Filler
  #   (U+FE00 - U+FE0F) "Variation Selectors" block
  #   (U+E0100 - U+E01EF) "Variation Selectors Supplement" block
  @unicode_invalid_char_pattern ~r"""
    [^[:alnum:]\p{M}._-]
    |
    [
      \x{034F}
      \x{115F}
      \x{1160}
      \x{17B4}
      \x{17B5}
      \x{180B}-\x{180D}
      \x{3164}
      \x{FFA0}
      \x{FE00}-\x{FE0F}
      \x{E0100}-\x{E01EF}
    ]
  """ux

  @invalid_leading_char_pattern ~r/\A[^[:alnum:]\p{M}_]+/
  @invalid_trailing_char_pattern ~r/[^[:alnum:]\p{M}]+\z/
  @repeated_special_char_pattern ~r/[-_.]{2,}/

  # æ˜¯å¦å¯ç”¨ Unicode ç”¨æˆ·åè§„åˆ™
  @unicode_idnames true

  @doc """
  å¯¹ä¼ å…¥çš„ç”¨æˆ·åæ‰§è¡Œæ‰€æœ‰æ ¼å¼éªŒè¯ï¼Œå¹¶å°†æ‰€æœ‰å‡ºç°çš„é”™è¯¯ç´¯åŠ è¿”å›ã€‚
  æœ€ç»ˆè¿”å›:
  - {:ok, idname} å¦‚æœéªŒè¯è¿‡ç¨‹ä¸­æ— é”™è¯¯
  - {:error, error} å¦‚æœå‡ºç°é”™è¯¯ï¼ˆä¿ç•™æ‰€æœ‰é”™è¯¯ä¿¡æ¯ï¼‰
  """
  def perform_validation(idname) do
    {normalize(idname), nil}
    |> idname_present()
    |> maybe_validate(&idname_length_min/1)
    |> maybe_validate(&idname_length_max/1)
    |> maybe_validate(&idname_char_valid/1)
    |> maybe_validate(&idname_char_allowed/1)
    |> maybe_validate(&idname_first_char_valid/1)
    |> maybe_validate(&idname_last_char_valid/1)
    |> maybe_validate(&idname_no_double_special/1)
    |> maybe_validate(&idname_does_not_end_with_confusing_suffix/1)
    |> finalize()
  end

  # åœ¨ pipeline ä¸­è‹¥å·²ç»æ˜¯ {idname, error} å°±ç›´æ¥è·³è¿‡åç»­éªŒè¯
  defp maybe_validate({_idname, nil} = state, fun), do: fun.(state)
  defp maybe_validate({idname, error}, _fun), do: {idname, error}

  # å¦‚æœ idname ä¸ä¸º nilï¼Œåˆ™è¿›è¡Œ Unicode NFC è§„èŒƒåŒ–
  defp normalize(nil), do: nil
  defp normalize(idname) when is_binary(idname), do: String.normalize(idname, :nfc)

  # åœ¨éªŒè¯å®Œæˆåï¼Œæ ¹æ®é”™è¯¯åˆ—è¡¨è¿”å› {:ok, idname} æˆ– {:error, error}
  defp finalize({idname, nil}), do: {:ok, idname}
  defp finalize({_idname, error}), do: {:error, error}

  # éªŒè¯ï¼šç”¨æˆ·åä¸èƒ½ä¸ºç©º
  defp idname_present({nil, _error}), do: {nil, "idname.blank"}

  defp idname_present({idname, error}) do
    if String.trim(idname) == "" do
      {idname, "idname.blank"}
    else
      {idname, error}
    end
  end

  # éªŒè¯ï¼šç”¨æˆ·åè‡³å°‘éœ€è¦è¾¾åˆ°æœ€å°å­—ç¬¦æ•°ï¼ˆæŒ‰ grapheme clusters è®¡ç®—ï¼‰
  defp idname_length_min({idname, _error} = state) do
    if is_nil(idname), do: state, else: do_idname_length_min(state)
  end

  defp do_idname_length_min({idname, error}) do
    if String.graphemes(idname) |> length() < @idname_min_length do
      {idname, "idname.short (min: #{@idname_min_length} characters)"}
    else
      {idname, error}
    end
  end

  # éªŒè¯ï¼šç”¨æˆ·åä¸èƒ½è¶…è¿‡æœ€å¤§å­—ç¬¦æ•°ï¼ˆåŒæ—¶æ£€æŸ¥ grapheme æ•°é‡å’Œå­—èŠ‚é•¿åº¦ï¼‰
  defp idname_length_max({idname, _error} = state) do
    if is_nil(idname), do: state, else: do_idname_length_max(state)
  end

  defp do_idname_length_max({idname, error}) do
    grapheme_count = String.graphemes(idname) |> length()
    byte_count = String.length(idname)

    cond do
      grapheme_count > @idname_max_length ->
        {idname, "idname.long (max: #{@idname_max_length} characters)"}

      byte_count > @max_chars ->
        {idname, "idname.too_long (exceeds #{@max_chars} bytes)"}

      true ->
        {idname, error}
    end
  end

  # éªŒè¯ï¼šç”¨æˆ·åä¸­æ˜¯å¦å­˜åœ¨æ— æ•ˆå­—ç¬¦
  defp idname_char_valid({idname, _error} = state) do
    if is_nil(idname), do: state, else: do_idname_char_valid(state)
  end

  defp do_idname_char_valid({idname, error}) do
    pattern =
      if @unicode_idnames,
        do: @unicode_invalid_char_pattern,
        else: @ascii_invalid_char_pattern

    if Regex.match?(pattern, idname) do
      {idname, "idname.characters (contains invalid characters)"}
    else
      {idname, error}
    end
  end

  # éªŒè¯ï¼šå¦‚æœæœ‰é¢å¤–å…è®¸çš„ Unicode å­—ç¬¦è§„åˆ™ï¼Œå¯åœ¨æ­¤æ‰©å±•ã€‚å½“å‰ç›´æ¥è¿”å› state
  defp idname_char_allowed({idname, error}) do
    {idname, error}
  end

  # éªŒè¯ï¼šç”¨æˆ·åç¬¬ä¸€ä¸ªå­—ç¬¦å¿…é¡»ä»¥å­—æ¯ã€æ•°å­—æˆ–ä¸‹åˆ’çº¿å¼€å¤´
  defp idname_first_char_valid({idname, _error} = state) do
    if is_nil(idname), do: state, else: do_idname_first_char_valid(state)
  end

  defp do_idname_first_char_valid({idname, error}) do
    clusters = String.graphemes(idname)
    first = List.first(clusters)

    if first && Regex.match?(@invalid_leading_char_pattern, first) do
      {idname, "idname.must_begin_with_alphanumeric_or_underscore (invalid first character)"}
    else
      {idname, error}
    end
  end

  # éªŒè¯ï¼šç”¨æˆ·åæœ€åä¸€ä¸ªå­—ç¬¦å¿…é¡»ä»¥å­—æ¯æˆ–æ•°å­—ç»“å°¾
  defp idname_last_char_valid({idname, _error} = state) do
    if is_nil(idname), do: state, else: do_idname_last_char_valid(state)
  end

  defp do_idname_last_char_valid({idname, error}) do
    clusters = String.graphemes(idname)
    last = List.last(clusters)

    if last && Regex.match?(@invalid_trailing_char_pattern, last) do
      {idname, "idname.must_end_with_alphanumeric (invalid last character)"}
    else
      {idname, error}
    end
  end

  # éªŒè¯ï¼šä¸å…è®¸è¿ç»­å‡ºç°ä¸¤ä¸ªç‰¹æ®Šå­—ç¬¦ï¼ˆ-ã€_ã€.ï¼‰
  defp idname_no_double_special({idname, _error} = state) do
    if is_nil(idname) or not Regex.match?(@repeated_special_char_pattern, idname) do
      state
    else
      {idname,
       "idname.must_not_contain_two_special_chars_in_seq (no double special chars allowed)"}
    end
  end

  # éªŒè¯ï¼šä¸å¾—ä»¥å®¹æ˜“é€ æˆæ··æ·†çš„åç¼€ç»“å°¾ (.jsã€.jsonã€.css ç­‰)
  defp idname_does_not_end_with_confusing_suffix({idname, _error} = state) do
    if is_nil(idname) or not Regex.match?(@confusing_extensions, idname) do
      state
    else
      {idname, "idname.must_not_end_with_confusing_suffix (confusing extension)"}
    end
  end
end
```

## ä¸­é—´ä»¶

ç”Ÿæˆä»¥ä¸‹ä¸­é—´ä»¶ï¼š

1. require\_authenticated\_userï¼š æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²ç™»å½•ï¼Œæœªç™»å½•åˆ™è¿”å› 401 é”™è¯¯
1. fetch\_current\_scope\_for\_user: ä»è¯·æ±‚ä¸­æå–å½“å‰ç”¨æˆ·çš„æƒé™èŒƒå›´ï¼ˆscopeï¼‰ï¼Œå¹¶åŠ è½½åˆ° conn.assigns ä¸­ï¼Œä¾›åç»­å¤„ç†ä½¿ç”¨

## Accounts ä¸‹çš„æ¨¡å—

1. Accounts.User ç­‰ å¯¹åº”æ•°æ®åº“è¡¨çš„ Ecto schema æ¨¡å—
1. Accounts.Scope ç”¨äºå®šä¹‰å’Œç®¡ç†ç”¨æˆ·æƒé™èŒƒå›´çš„æ¨¡å—
1. Accounts.UserNotifier ç®¡ç†é‚®ä»¶å‘é€çš„æ¨¡å—ï¼ŒåŒ…æ‹¬é‚®ä»¶æ¨¡æ¿çš„ç”Ÿæˆ
